<!DOCTYPE html>
<!--
  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.
-->
<html lang="en">
  <head>
    <meta charset="utf8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Extract the original Scratch project from HTML or zip files generated by TurboWarp-Based Packagers, forkphorus packager, or HTMLifier.">
    <meta name="theme-color" content="#ff4c4c">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline'">
    <title>Unpackager for Scratch, TurboWarp, MistWarp, forkphorus, HTMLifier</title>
    <style>
      :root {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      }
      @media (prefers-color-scheme: dark) {
        :root {
          color: #eee;
          background-color: #111;
          color-scheme: dark;
        }
        a {
          color: #4af;
        }
      }

      h1, h2, h3 {
        font-weight: normal;
      }

      main {
        max-width: 480px;
        margin: auto;
      }

      .code {
        font-family: monospace;
      }

      input[type=file] {
        width: 100%;
      }

      .bulk-controls {
        background-color: rgba(0, 100, 200, 0.1);
        border: 1px solid rgba(0, 100, 200, 0.3);
        border-radius: 8px;
        padding: 15px;
        margin: 15px 0;
      }

      @media (prefers-color-scheme: dark) {
        .bulk-controls {
          background-color: rgba(100, 150, 255, 0.15);
          border: 1px solid rgba(100, 150, 255, 0.4);
        }
      }

      .bulk-controls label {
        display: block;
        margin: 8px 0;
      }

      .bulk-controls button {
        margin: 5px 10px 5px 0;
        padding: 8px 16px;
        border: 1px solid #ccc;
        border-radius: 4px;
        background-color: #f8f8f8;
        color: #333;
        font-size: 14px;
        cursor: pointer;
        min-width: 80px;
      }

      .bulk-controls button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        background-color: #e0e0e0;
        color: #999;
      }

      .bulk-controls button:hover:not(:disabled) {
        background-color: #e8e8e8;
        border-color: #999;
      }

      .bulk-controls button:active:not(:disabled) {
        background-color: #d8d8d8;
        transform: translateY(1px);
      }

      @media (prefers-color-scheme: dark) {
        .bulk-controls button {
          background-color: #444;
          color: #eee;
          border-color: #666;
        }

        .bulk-controls button:disabled {
          background-color: #333;
          color: #666;
          border-color: #555;
        }

        .bulk-controls button:hover:not(:disabled) {
          background-color: #555;
          border-color: #888;
        }

        .bulk-controls button:active:not(:disabled) {
          background-color: #333;
        }
      }

      .download-section a {
        display: block;
      }

      .error-item {
        background-color: rgba(255, 0, 0, 0.1);
        border: 1px solid rgba(255, 0, 0, 0.3);
        padding: 8px;
        margin: 5px 0;
        border-radius: 4px;
      }

      .success-item {
        background-color: rgba(0, 255, 0, 0.1);
        border: 1px solid rgba(0, 255, 0, 0.3);
        padding: 8px;
        margin: 5px 0;
        border-radius: 4px;
      }

      .drag-effect {
        opacity: 0;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
        border: 10px dashed rgb(110, 110, 255);
        pointer-events: none;
        transition: .2s opacity;
      }
      .dragging .drag-effect {
        opacity: 1;
      }

      .notice {
        padding: 4px;
        border: 1px solid red;
        background-color: rgba(255, 0, 0, 0.205);
        border-radius: 4px;
      }

      pre {
        white-space: pre-wrap;
      }
    </style>
  </head>

  <body>
    <main>
      <h1>Unpackager</h1>

      <noscript><p>The unpackager needs JavaScript.</p></noscript>

      <p>Select or drop HTML or zip files, and the unpackager will try to extract the original Scratch projects. You can select multiple files for bulk processing.</p>

      <input type="file" class="file-input" accept=".zip, .html" multiple autocomplete="off">

      <div class="bulk-controls" style="display: none;">
        <p><strong>Bulk Processing Options:</strong></p>
        <label>
          Batch size: <select class="batch-size">
            <option value="10">10 files at once</option>
            <option value="25" selected>25 files at once</option>
            <option value="50">50 files at once</option>
            <option value="100">100 files at once</option>
          </select>
        </label>
        <label>
          <input type="checkbox" class="auto-download"> Auto-download completed files
        </label>
        <button class="pause-resume-btn" disabled>Pause</button>
        <button class="cancel-btn" disabled>Cancel</button>
        <button class="download-all-btn" disabled style="display: none;">Download All</button>
        <div class="progress-container" style="margin-top: 10px;">
          <div class="progress-bar" style="width: 100%; height: 20px; background-color: #ddd; border-radius: 10px; overflow: hidden;">
            <div class="progress-fill" style="height: 100%; background-color: #4caf50; width: 0%; transition: width 0.3s;"></div>
          </div>
          <div class="progress-text" style="margin-top: 5px; font-size: 14px;"></div>
        </div>
      </div>

      <p class="download-section"></p>

      <p class="notice">Having access to a packaged version of a project does not necessarily mean that you are legally allowed to unpackage the project, use it, modify it, redistribute it, sell it, or otherwise ignore copyright law. Ask the creator of the project for more information.</p>

      <h2>Supported packagers</h2>
      <p>Unpackager is known to work on projects generated using these:</p>
      <ul>
        <li><a href="https://packager.turbowarp.org/">TurboWarp Packager</a> - all formats including HTML, zip, exe (script positions and comments are lost)</li>
        <li><a href="https://packager.warp.mistium.com/">MistWarp Packager</a> - A fork of TurboWarp's packager for MistWarp</li>
        <li><a href="https://forkphorus.github.io/packager/">forkphorus packager</a> - all formats including HTML, zip, NW.js</li>
        <li><a href="https://sheeptester.github.io/htmlifier/">HTMLifier</a> - HTML, zip (HTMLifier converts Scratch 2 projects to Scratch 3 so unpackaged project may be inaccurate)</li>
      </ul>

      <h2>Bulk Processing</h2>
      <p>The unpackager now supports efficient bulk processing of multiple files:</p>
      <ul>
        <li><strong>Batch Processing:</strong> Files are processed in configurable batches (10-100 files at once) to optimize performance</li>
        <li><strong>Progress Tracking:</strong> Real-time progress bar and statistics showing success/error counts</li>
        <li><strong>Pause/Resume:</strong> Ability to pause and resume bulk operations</li>
        <li><strong>Auto-download:</strong> Optional automatic downloading of successfully processed files</li>
        <li><strong>Error Handling:</strong> Individual file errors don't stop the entire batch - failed files are clearly marked</li>
        <li><strong>Memory Management:</strong> Efficient processing prevents browser memory issues with large file sets</li>
      </ul>

      <h2>Bugs</h2>
      <p>Report bugs (such as files that couldn't be unpackaged) <a href="https://github.com/MistWarp/unpackager/issues">on GitHub</a>.</p>

      <h2>Code</h2>
      <p>Unpackager is <a href="https://github.com/MistWarp/unpackager">open source</a>.</p>

      <h2>Privacy</h2>
      <p>Files are processed locally on your computer and never sent to any server.</p>

      <h2>I don't want people to unpackage my projects</h2>
      <p>All of these project packagers work by embedding the project file and a project runner into the same file. When you open the file, some code passes that project file to the project runner. The unpackager simply does the same process.</p>
      <p>This problem is not unique to Scratch projects. Anything web-based has similar issues, as do game engines like Unity.</p>
      <p>We know this makes some people uncomfortable, but realistically you shouldn't worry. If you're worried about people stealing your assets, copyright law still exists. If you're selling something, pirates were never going to pay. Cheaters will always find a way. All of these problems existed long before the unpackager did.</p>
      <p>If this still bothers you, the topic to research is "DRM".</p>
    </main>

    <div class="drag-effect"></div>

    <script src="dependencies/jszip.min.js"></script>
    <script src="unpackager.js"></script>
    <script>
      (function() {
        'use strict';

        const fileInput = document.querySelector('.file-input');
        const downloadSection = document.querySelector('.download-section');
        const bulkControls = document.querySelector('.bulk-controls');
        const batchSizeSelect = document.querySelector('.batch-size');
        const autoDownloadCheckbox = document.querySelector('.auto-download');
        const pauseResumeBtn = document.querySelector('.pause-resume-btn');
        const cancelBtn = document.querySelector('.cancel-btn');
        const downloadAllBtn = document.querySelector('.download-all-btn');
        const progressFill = document.querySelector('.progress-fill');
        const progressText = document.querySelector('.progress-text');

        let isProcessing = false;
        let isPaused = false;
        let shouldCancel = false;
        let currentBatch = 0;
        let totalFiles = 0;
        let processedFiles = 0;
        let successCount = 0;
        let errorCount = 0;
        let successfulBlobs = []; // Store successful blobs for download all

        const processFile = async (file) => {
          const unpackaged = await unpackage(file);
          const type = unpackaged.type;
          const data = unpackaged.data;
          
          // Remove the original extension and replace with the new one
          const baseName = file.name.replace(/\.(html?|zip)$/i, '');
          const name = `${baseName}.${type}`;

          const blob = new Blob([data], {
            type: `application/x.scratch.${type}`
          });
          blob.name = name;
          return blob;
        };

        const updateProgress = () => {
          const percentage = totalFiles > 0 ? (processedFiles / totalFiles) * 100 : 0;
          progressFill.style.width = `${percentage}%`;
          progressText.textContent = `Progress: ${processedFiles}/${totalFiles} files processed | Success: ${successCount} | Errors: ${errorCount}`;
        };

        const createResultItem = (fileName, isSuccess, content, blob = null) => {
          const item = document.createElement('div');
          item.className = isSuccess ? 'success-item' : 'error-item';
          
          if (isSuccess && blob) {
            // Store blob for download all functionality
            successfulBlobs.push(blob);
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = blob.name;
            link.textContent = `✓ ${blob.name} (${(blob.size / 1000 / 1000).toFixed(2)}MB)`;
            item.appendChild(link);
            
            if (autoDownloadCheckbox.checked) {
              setTimeout(() => link.click(), 100);
            }
          } else if (isSuccess) {
            item.textContent = `✓ ${content}`;
          } else {
            const errorContent = document.createElement('div');
            errorContent.innerHTML = `<strong>✗ ${fileName}:</strong><br><pre style="margin: 5px 0; font-size: 12px;">${content}</pre>`;
            item.appendChild(errorContent);
          }
          
          downloadSection.appendChild(item);
          return item;
        };

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        const processBatch = async (files, batchSize) => {
          const batches = [];
          for (let i = 0; i < files.length; i += batchSize) {
            batches.push(files.slice(i, i + batchSize));
          }

          for (let i = 0; i < batches.length && !shouldCancel; i++) {
            currentBatch = i + 1;
            
            // Wait if paused
            while (isPaused && !shouldCancel) {
              await sleep(100);
            }
            
            if (shouldCancel) break;

            const batch = batches[i];
            const batchPromises = batch.map(async (file) => {
              try {
                const blob = await processFile(file);
                processedFiles++;
                successCount++;
                updateProgress();
                return { success: true, file, blob };
              } catch (error) {
                processedFiles++;
                errorCount++;
                updateProgress();
                console.error(`Error processing ${file.name}:`, error);
                return { success: false, file, error };
              }
            });

            const results = await Promise.all(batchPromises);
            
            // Create result items for this batch
            results.forEach(result => {
              if (result.success) {
                createResultItem(result.file.name, true, '', result.blob);
              } else {
                createResultItem(result.file.name, false, result.error.stack || result.error.message || result.error);
              }
            });

            // Small delay between batches to prevent UI freezing
            await sleep(50);
          }
        };

        const processInput = async () => {
          const files = Array.from(fileInput.files);
          if (files.length === 0) {
            return;
          }

          // Clear previous results
          while (downloadSection.firstChild) {
            if (downloadSection.firstChild.href) {
              URL.revokeObjectURL(downloadSection.firstChild.href);
            }
            downloadSection.firstChild.remove();
          }

          // Reset counters
          totalFiles = files.length;
          processedFiles = 0;
          successCount = 0;
          errorCount = 0;
          successfulBlobs = [];
          shouldCancel = false;
          isPaused = false;
          isProcessing = true;

          // Show bulk controls for multiple files
          if (files.length > 1) {
            bulkControls.style.display = 'block';
            pauseResumeBtn.disabled = false;
            cancelBtn.disabled = false;
            downloadAllBtn.style.display = 'none';
            downloadAllBtn.disabled = true;
            pauseResumeBtn.textContent = 'Pause';
          } else {
            bulkControls.style.display = 'none';
          }

          updateProgress();

          try {
            const batchSize = parseInt(batchSizeSelect.value);
            await processBatch(files, batchSize);

            if (shouldCancel) {
              progressText.textContent += ' | CANCELLED';
            } else {
              progressText.textContent += ' | COMPLETED';
            }
          } catch (e) {
            console.error('Bulk processing error:', e);
            createResultItem('Bulk Processing', false, e.stack || e.message || e);
          } finally {
            isProcessing = false;
            pauseResumeBtn.disabled = true;
            cancelBtn.disabled = true;
            
            // Show download all button if there are successful files
            if (successfulBlobs.length > 0) {
              downloadAllBtn.style.display = 'inline-block';
              downloadAllBtn.disabled = false;
              downloadAllBtn.textContent = `Download All (${successfulBlobs.length})`;
            }
          }
        };

        const togglePause = () => {
          if (!isProcessing) return;
          
          isPaused = !isPaused;
          pauseResumeBtn.textContent = isPaused ? 'Resume' : 'Pause';
          
          if (isPaused) {
            progressText.textContent += ' | PAUSED';
          } else {
            updateProgress(); // This will remove the PAUSED text
          }
        };

        const cancelProcessing = () => {
          if (!isProcessing) return;
          
          shouldCancel = true;
          isPaused = false;
          pauseResumeBtn.textContent = 'Pause';
          pauseResumeBtn.disabled = true;
          cancelBtn.disabled = true;
        };

        const downloadAll = () => {
          if (successfulBlobs.length === 0) return;
          
          // Download all successful files with a small delay between each
          successfulBlobs.forEach((blob, index) => {
            setTimeout(() => {
              const link = document.createElement('a');
              link.href = URL.createObjectURL(blob);
              link.download = blob.name;
              link.style.display = 'none';
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              URL.revokeObjectURL(link.href);
            }, index * 200); // 200ms delay between downloads
          });
        };

        // Event listeners
        fileInput.addEventListener('change', processInput);
        pauseResumeBtn.addEventListener('click', togglePause);
        cancelBtn.addEventListener('click', cancelProcessing);
        downloadAllBtn.addEventListener('click', downloadAll);

        document.documentElement.addEventListener('drop', (e) => {
          document.documentElement.classList.remove('dragging');
          if (e.dataTransfer.types.includes('Files')) {
            e.preventDefault();
            fileInput.files = e.dataTransfer.files;
            processInput();
          }
        });

        document.documentElement.addEventListener('dragleave', (e) => {
          document.documentElement.classList.remove('dragging');
        });

        document.documentElement.addEventListener('dragover', (e) => {
          if (e.dataTransfer.types.includes('Files')) {
            document.documentElement.classList.add('dragging');
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
          }
        });
      }());
    </script>
  </body>
</html>
